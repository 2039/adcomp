/**
\mainpage Comprehensive Documentation of Functions and Classes (API)

<ul>
  <li> \b Modules: Introduction and summary of TMB (start here if you are new).</li>
</ul>



*/

/** \defgroup Tutorial Getting started


A TMB projects consists of an R file (*.R) and a C++ file (*.cpp). 
The R file does pre- and post processing of data in addition to maximizing
the log-likelihood contained in *.cpp. See \ref Examples for more details.
All R functions are documented within the standard help system i R.
This tutorial describes how to write the C++ file, and assumes familiarity with C++ and to some extent with R.

The purpose of the C++ program is to evaluate the objective function, i.e. the negative log-likelihood
of the model. The program is compiled and called from R, where
it can be fed to a function minimizer like nlminb().

The objective function should be of the following C++ type:
   \code
#include <TMB.hpp>

template<class Type>
Type objective_function<Type>::operator() ()
{
.... Here goes your C++ code ..... 
}
   \endcode
The first line includes the source code for the whole TMB package (and all its dependencies).
The objective function is a templated class where <tt><Type></tt> is
the data type of both the input values and the return value of the objective function.
This allows us to evaluate both the objective function and its derivatives using the same chunk of C++ code
(and the AD package CppAD). The technical aspects of this are hidden from the user. There is however one aspect 
that surprises the new TMB user. When a constant like "1.2" is used
in a calculation that affects the return value it must be "cast" to Type:
   \code
   Type nll;		// Define variable that holds the return value (neg. log. lik)
   nll = Type(1.2);	// Assign value 1.2; a cast is needed.
   \endcode

<h2>Obtaining data and parameter values from R</h2>
Obviously, we will need to pass both data and parameter values to the objective function.
This is done through a set of macros that TMB defines for us. To see
which macros are available start typing <tt>DATA_</tt> or <tt>PARAMETER_</tt> 
in the Doxygen search field of your browser (you may need to refresh the browser window between
each time you make a new search). A simple example if you want to read a vector
of numbers (doubles) is the following
   \code
  DATA_VECTOR(x);               // Vector x(0),x(1),...,x(n-1), where n is the length of x
   \endcode
Note that all vectors and matrices in TMB uses a \b zero-based indexing scheme.
It is not necessary to explicitely pass the dimension of "x", but it is often convenient.
The dimension of x is set on the R side when the C++ program is called, and
there are ways of retrieving the dimenson of x inside the C++ program.

<h2>An extended C++ language</h2>
TMB extends C++ with functionality that is important for formulating
likelihood functions. You have three toolboxes available:
- Standard C++ used for infrastructure like loops etc.
- Vector, matrix and array library (see \ref matrix_arrays)
- Probability distributions (see \ref Distributions)

In addition to the variables defined through the <tt>DATA_</tt> or <tt>PARAMETER_</tt>
macros there can be "local" variables, for which ordinary C++ scoping rules apply.
There must also be a variable that holds the return value (neg. log. likelihood).
   \code
  DATA_VECTOR(x);               // Vector x(0),x(1),...,x(n-1)
  Type tmp = x(1);
  Type nll=tmp*tmp; 
   \endcode
As in ordinary C++ local variable tmp must be assign a value before it can enter into
a calculation.

<h2>Statistical modelling</h2>
TMB can handle complex statistical problems with hierarchical structure (latent
random variables) and multiple data sources.  Latent random variables must be continuous 
(discrete distributions are not handled).  The <tt>PARAMETER_</tt> macros are used to pass 
two types of parameters.
- \b Parameters: to be estimated by maximum likelihood. These include fixed effects and variance
  components in the mixed model litterature. They will also correspond to hyper parameters
  with non-informative priors in the Bayesian literature.
- \b Latent \b random \b variables: to be integrated out of the likelihood using a Laplace approximation. 

Which of these are chosen is controlled from R, via the <tt>random</tt> argument to the function <tt>MakeADFun</tt>. However,
on the C++ side it is usually necessary to assign a probablity distribution to the parameter.

The purpose of the C++ program is to calculate the (negative) joint density of data and latent
random variables. Each datum and individual latent random gives a contribution
to log likelihood, which may be though of as a "distribution assignment" by users
familiar with software in the BUGS family.
   \code
  PARAMETER_VECTOR(u);          // Latent random variable 
  Type nll = Type(0);		// Return value
  nll -= dnorm(u(0),0,1)	// Distributional assignment: u(0) ~ N(0,1) 
   \endcode
The following rules apply:
- Distribution assignments do not need to take place before the latent variable
  is used in a calculation.
- More complicated distributionional assigments are allowed, say u(0)-u(1) ~ N(0,1),
  but this requires the user to have a deeper understanding of the probabilistic aspects of the model.
- For latent variables only normal distributions should be used (otherwise
  the Laplace approximation will perform poorly). For response variables
  all probability distributions (discrete or continuous) are allowed.
  If a non-gaussian latent is needed the "transformation trick" can be used.
- The library \ref Distributions contains many probability distributions, especially
  multivariate normal distributions. For probability distributions not contained
  in the library, the user can use raw C++ code. 
   \code
  DATA_VECTOR(y);          	// Data vector
  Type nll = Type(0);		// Return value
  nll -= log(Type(0.5)) - abs(y(0));	// y(0) has a Laplace distribution
   \endcode

See \ref Examples for more examples


*/

/** \defgroup matrix_arrays Matrices and arrays


\section Relation_R Relationship to R
In R you can apply both matrix multiplication ("%*%")
and elementwise multiplication ("*") to objects of
type "matrix", i.e. it is the operator that determines the operation.
In TMB we instead have two different types of objects, while
the multiplication operator "*" is the same: 
- \c matrix: linear algebra
- \c array: elementwise operations; () and [] style indexing.
- \c vector: can be used in linear algebra with \c matrix, but at the same
time admits R style element-wise operations.

See \ref matrix_arrays.cpp "matrix_arrays.cpp" for examples of use.


\section Relation_Eigen Relationship to Eigen
The TMB types \c matrix and \c array inherits from the the Eigen
types Matrix and Array. The advanced user of TMB will befinit from familiarity with
the <a href="http://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html">Eigen documentation</a>.

*/

/** \defgroup R_style_distribution R style probability distributions

\brief Probability distributions (discrete and continuous) for use in the likelihood function. 

Attempts have been made to make the interface (function name and arguments) as close as possible 
to that of R. 

- The densities (\c d...) are provided both in the discrete and continuous case, 
	cumulative distributions (\c p...) and inverse cumulative distributions (\c q...) 
	are provided only for continuous distributions.
- Arguments of the \c vector are supported, but not \c array or \c matrix.
  \code 
  DATA_VECTOR(x);
  vector<Type> rate(10);
  matrix<Type> rate_matrix(10,10);
  dexp(x,rate);                      // OK
  dexp(x,rate_matrix);               // Not allowed
  \endcode 
  See ... for how to deal with \c array or \c matrix objects. 
- Note that \c DATA_SCALAR(), \c DATA_IVECTOR() and \c DATA_INTEGER() can also directly be used as arguments.
- Vector arguments must all be of the same length (no recycling of elements). If vectors of different lengths are
  used an "out of range" error will occur, and can be picked up by the debugger.
- To sum over elements in the vector returned use \code dexp(x,rate).sum();\endcode 
*/

/** \defgroup Densities Multivariate normal densities (distributions)

\brief To come..

*/

/** \defgroup Examples TMB examples
For a list of all examples please click on the "Examples" tab on
the top of the page. 
- For each \c .cpp file in the Example Collection there is a \c .R file that will
  build an run the example from R.

Simple example:
\include simple.cpp

\example ar1_4D.cpp
\example called_from_R.cpp
\example linreg.cpp
\example linreg_parallel.cpp
\example longlinreg.cpp
\example matrix_arrays.cpp
\example mvrw.cpp
\example mvrw_sparse.cpp
\example nmix.cpp
\example orange_big.cpp
\example rw_parallel.cpp
\example sam.cpp
\example sde_linear.cpp
\example sdv_multi_compact.cpp
\example sdv_multi.cpp
\example socatt.cpp
\example spatial.cpp
\example thetalog.cpp

*/

/** \defgroup Errors Compilation and run time errors

<h2>Compilation errors</h2>
It may be hard to understand the compilation errors for the following reasons
- ???

<h2>Run time errors</h2>
If you get run time errors you should use the C++ debugger. The R package TMB
contains an R-interface to the debugger:
   \code
   help(gdbsource)
   gdbsource("simple.R", interactive = FALSE)
   \endcode
   
*/


