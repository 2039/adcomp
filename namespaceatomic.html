<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TMB Documentation: atomic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TMB Documentation
   &#160;<span id="projectnumber">v1.6.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atomic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace with special functions and derivatives.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceatomic_1_1Rmath"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic_1_1Rmath.html">Rmath</a></td></tr>
<tr class="memdesc:namespaceatomic_1_1Rmath"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace with double versions of R special math library. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1forrev__derivatives.html">forrev_derivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General class to construct 'double versions' of the generalized symbol.  <a href="structatomic_1_1forrev__derivatives.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1Block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1Triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1nestedTriangle.html">nestedTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of 'block-binomial' matrix.  <a href="structatomic_1_1nestedTriangle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatomic_1_1nestedTriangle_3_010_01_4.html">nestedTriangle&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab6763243aac45f66d92084428c131133"><td class="memTemplParams" colspan="2">template&lt;class matrix_pade &gt; </td></tr>
<tr class="memitem:ab6763243aac45f66d92084428c131133"><td class="memTemplItemLeft" align="right" valign="top">matrix_pade&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ab6763243aac45f66d92084428c131133">expm</a> (matrix_pade <a class="el" href="tmbutils__extra_8cpp.html#a955f504eccf76b4eb2489c0adab03121">A</a>)</td></tr>
<tr class="separator:ab6763243aac45f66d92084428c131133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf45e4527ec63384948fc5deda6fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ab1cf45e4527ec63384948fc5deda6fac">expm</a> (<a class="el" href="structvector.html">vector</a>&lt; <a class="el" href="structmatrix.html">matrix</a>&lt; double &gt; &gt; args)</td></tr>
<tr class="separator:ab1cf45e4527ec63384948fc5deda6fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd576878b02e6f3671443801b00a82"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a5cfd576878b02e6f3671443801b00a82"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a5cfd576878b02e6f3671443801b00a82">args2vector</a> (<a class="el" href="structvector.html">vector</a>&lt; <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; &gt; args, int skip=-1)</td></tr>
<tr class="separator:a5cfd576878b02e6f3671443801b00a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface to atomic functions.</div></td></tr>
<tr class="memitem:a0a6e5aae5b2ae6844132f48319048dd5"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a0a6e5aae5b2ae6844132f48319048dd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a0a6e5aae5b2ae6844132f48319048dd5">vec2mat</a> (CppAD::vector&lt; Type &gt; x, int m, int n, int offset=0)</td></tr>
<tr class="memdesc:a0a6e5aae5b2ae6844132f48319048dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert segment of CppAD::vector to Eigen::Matrix.  <a href="#a0a6e5aae5b2ae6844132f48319048dd5">More...</a><br/></td></tr>
<tr class="separator:a0a6e5aae5b2ae6844132f48319048dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d9a6c916055fb65ca680ff55e7d7c7"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a58d9a6c916055fb65ca680ff55e7d7c7"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a58d9a6c916055fb65ca680ff55e7d7c7">mat2vec</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a58d9a6c916055fb65ca680ff55e7d7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Eigen::Matrix to CppAD::vector by stacking the matrix columns.  <a href="#a58d9a6c916055fb65ca680ff55e7d7c7">More...</a><br/></td></tr>
<tr class="separator:a58d9a6c916055fb65ca680ff55e7d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481538cdd18f419396ee65eaec62c0ba"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a481538cdd18f419396ee65eaec62c0ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a481538cdd18f419396ee65eaec62c0ba">matmul</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; y)</td></tr>
<tr class="memdesc:a481538cdd18f419396ee65eaec62c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply.  <a href="#a481538cdd18f419396ee65eaec62c0ba">More...</a><br/></td></tr>
<tr class="separator:a481538cdd18f419396ee65eaec62c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:acf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#acf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="separator:acf8e4c3cd2dc2c2859f8c52ad40ccec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aed041873dea3426da0d0bac628583"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a06aed041873dea3426da0d0bac628583"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a06aed041873dea3426da0d0bac628583">matinvpd</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x, Type &amp;<a class="el" href="namespaceatomic.html#af7937bd97f9d5a2e80c00d03faf3a7c2">logdet</a>)</td></tr>
<tr class="separator:a06aed041873dea3426da0d0bac628583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5555ee5c905915a566d47d7f2830424"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ae5555ee5c905915a566d47d7f2830424"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ae5555ee5c905915a566d47d7f2830424">logdet</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="separator:ae5555ee5c905915a566d47d7f2830424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2548954dc9fb42802b8d41e959337d"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:acf2548954dc9fb42802b8d41e959337d"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#acf2548954dc9fb42802b8d41e959337d">nldmvnorm</a> (<a class="el" href="structvector.html">vector</a>&lt; Type &gt; x, <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; Sigma)</td></tr>
<tr class="separator:acf2548954dc9fb42802b8d41e959337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ac09966696ad9685dc8047d6c582bc0ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ac09966696ad9685dc8047d6c582bc0ae">expm</a> (<a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ac09966696ad9685dc8047d6c582bc0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="#ac09966696ad9685dc8047d6c582bc0ae">More...</a><br/></td></tr>
<tr class="separator:ac09966696ad9685dc8047d6c582bc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User defined atomic functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section note"><dt>Note</dt><dd>The following procedure is automatically performed with the macro REGISTER_ATOMIC.</dd></dl>
<pre class="fragment">    Given function f0. Define recursively higher order reverse
    mode derivatives:

    f0: R^(n)         -&gt;  R^(m)     (  x           -&gt; f0 (x)    )
    f1: R^(n+m)       -&gt;  R^(n)     ( (x,w1)       -&gt; f0'(x)*w1 )
    f2: R^(n+m+n)     -&gt;  R^(n+m)   ( (x,w1,w2)    -&gt; f1'(x)*w2 )
    f3: R^(n+m+n+n+m) -&gt;  R^(n+m+n) ( (x,w1,w2,w3) -&gt; f2'(x)*w3 )

    1. We define a 'generalized symbol' to represent all of these.
    _Reverse_mode_AD_ is trivially obtained for this symbol by calling
    itself on a higher level. Each occurance on the tape will occupy
    O(n+m) memory units independent of the number of flops performed
    by f0.

    2. _Double_versions_ of the generalized symbol are obtained using
    nested AD types to tape f0, then recursively tape forward and
    reverse mode sweeps.

    Finally, given (1) and (2) the macro TMB_ATOMIC_VECTOR_FUNCTION
    will generate the atomic symbol.
</pre> </div></td></tr>
<tr class="memitem:a472890c63423ca4faac24b60ebc7dfb1"><td class="memTemplParams" colspan="2">template&lt;class Base , class Func &gt; </td></tr>
<tr class="memitem:a472890c63423ca4faac24b60ebc7dfb1"><td class="memTemplItemLeft" align="right" valign="top">CppAD::ADFun&lt; Base &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a472890c63423ca4faac24b60ebc7dfb1">generate_tape</a> (Func f, <a class="el" href="structvector.html">vector</a>&lt; double &gt; x_)</td></tr>
<tr class="memdesc:a472890c63423ca4faac24b60ebc7dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tape of a given template <em>functor</em> (Will be used to tape 'f0' for different nested AD types)  <a href="#a472890c63423ca4faac24b60ebc7dfb1">More...</a><br/></td></tr>
<tr class="separator:a472890c63423ca4faac24b60ebc7dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a28796fe0610d708c2694a5cd6c2d6"><td class="memTemplParams" colspan="2">template&lt;class Base &gt; </td></tr>
<tr class="memitem:a87a28796fe0610d708c2694a5cd6c2d6"><td class="memTemplItemLeft" align="right" valign="top">CppAD::ADFun&lt; Base &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a87a28796fe0610d708c2694a5cd6c2d6">forrev</a> (CppAD::ADFun&lt; AD&lt; Base &gt; &gt; *padf, <a class="el" href="structvector.html">vector</a>&lt; double &gt; x_)</td></tr>
<tr class="memdesc:a87a28796fe0610d708c2694a5cd6c2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift tape of fn up one level by taping forward and reverse sweeps. Note: x_ needs only have length equal to the input domain dimension of f0. Zeros are filled in for all range directions.  <a href="#a87a28796fe0610d708c2694a5cd6c2d6">More...</a><br/></td></tr>
<tr class="separator:a87a28796fe0610d708c2694a5cd6c2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add38af63d55c1d476da416ee12ea2955"><td class="memTemplParams" colspan="2">template&lt;class ADBase &gt; </td></tr>
<tr class="memitem:add38af63d55c1d476da416ee12ea2955"><td class="memTemplItemLeft" align="right" valign="top">CppAD::ADFun&lt; double &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#add38af63d55c1d476da416ee12ea2955">multi_forrev</a> (CppAD::ADFun&lt; ADBase &gt; *padf, <a class="el" href="structvector.html">vector</a>&lt; double &gt; x_)</td></tr>
<tr class="memdesc:add38af63d55c1d476da416ee12ea2955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively apply forrev until the lowest Base level (double)  <a href="#add38af63d55c1d476da416ee12ea2955">More...</a><br/></td></tr>
<tr class="separator:add38af63d55c1d476da416ee12ea2955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97cc856848039d8348814b3cd969053"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae97cc856848039d8348814b3cd969053"><td class="memTemplItemLeft" align="right" valign="top">CppAD::ADFun&lt; double &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ae97cc856848039d8348814b3cd969053">multi_forrev&lt; double &gt;</a> (CppAD::ADFun&lt; double &gt; *padf, <a class="el" href="structvector.html">vector</a>&lt; double &gt; x_)</td></tr>
<tr class="separator:ae97cc856848039d8348814b3cd969053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f24dc404dcd4e67da9eb5431af90a25"><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr class="memitem:a8f24dc404dcd4e67da9eb5431af90a25"><td class="memTemplItemLeft" align="right" valign="top">CppAD::ADFun&lt; double &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a8f24dc404dcd4e67da9eb5431af90a25">tape_symbol</a> (Func f, <a class="el" href="structvector.html">vector</a>&lt; double &gt; x)</td></tr>
<tr class="memdesc:a8f24dc404dcd4e67da9eb5431af90a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tape symbol up to any order.  <a href="#a8f24dc404dcd4e67da9eb5431af90a25">More...</a><br/></td></tr>
<tr class="separator:a8f24dc404dcd4e67da9eb5431af90a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a586c7851a9b0f3ae2bccde6757b23b89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a586c7851a9b0f3ae2bccde6757b23b89">atomicFunctionGenerated</a> = false</td></tr>
<tr class="separator:a586c7851a9b0f3ae2bccde6757b23b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Atomic functions.</h2></td></tr>
<tr class="memitem:a6dd8f490d3ca65864095d40de4f9fa85"><td class="memItemLeft" align="right" valign="top">typedef Eigen::LDLT<br class="typebreak"/>
&lt; Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a6dd8f490d3ca65864095d40de4f9fa85">LDLT_t</a></td></tr>
<tr class="separator:a6dd8f490d3ca65864095d40de4f9fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac815ccadc31fa4bf92660fe5c25eab"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a4ac815ccadc31fa4bf92660fe5c25eab"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a4ac815ccadc31fa4bf92660fe5c25eab">dnorm1</a> (Type x)</td></tr>
<tr class="memdesc:a4ac815ccadc31fa4bf92660fe5c25eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard normal density function 'dnorm1'. Needed to define derivative of 'pnorm1'.  <a href="#a4ac815ccadc31fa4bf92660fe5c25eab">More...</a><br/></td></tr>
<tr class="separator:a4ac815ccadc31fa4bf92660fe5c25eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501e991d939deb58f6455904262be81"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ae501e991d939deb58f6455904262be81"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ae501e991d939deb58f6455904262be81">pnorm1</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ae501e991d939deb58f6455904262be81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'.  <a href="#ae501e991d939deb58f6455904262be81">More...</a><br/></td></tr>
<tr class="separator:ae501e991d939deb58f6455904262be81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a6bb7b5e1dbb5ed751e3320b3f07bef77">qnorm1</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of standard normal quantile function. Derivative is expressed through 'dnorm1'.  <a href="#a6bb7b5e1dbb5ed751e3320b3f07bef77">More...</a><br/></td></tr>
<tr class="separator:a6bb7b5e1dbb5ed751e3320b3f07bef77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#ab86d10e39e1b3aebc1fbd26aa26346d4">D_incpl_gamma_shape</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]" src="form_0.png"/>
</p>
<p> where the 4 input parameters are passed as a vector <img class="formulaInl" alt="$x=(y,\lambda,n,c)$" src="form_1.png"/>. Note that the normalized incomplete gamma function is obtained as the special case <img class="formulaInl" alt="$n=0$" src="form_2.png"/> and <img class="formulaInl" alt="$c=-\log \Gamma(\lambda)$" src="form_3.png"/>. Valid parameter range: <img class="formulaInl" alt="$x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}$" src="form_4.png"/>.  <a href="#ab86d10e39e1b3aebc1fbd26aa26346d4">More...</a><br/></td></tr>
<tr class="separator:ab86d10e39e1b3aebc1fbd26aa26346d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6bfb1722819752d1ad1084a6de6f27"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aca6bfb1722819752d1ad1084a6de6f27"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#aca6bfb1722819752d1ad1084a6de6f27">inv_incpl_gamma</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:aca6bfb1722819752d1ad1084a6de6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of inverse of scaled incomplete gamma function. Given <img class="formulaInl" alt="$z$" src="form_5.png"/> find <img class="formulaInl" alt="$y$" src="form_6.png"/> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ z = \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \:dt \]" src="form_7.png"/>
</p>
<p> where the 3 input parameters are passed as a vector <img class="formulaInl" alt="$x=(z,\lambda,c)$" src="form_8.png"/>. The special case <img class="formulaInl" alt="$c=-\log \Gamma(\lambda)$" src="form_3.png"/> gives the inverse normalized incomplete gamma function. Valid parameter range: <img class="formulaInl" alt="$x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{R}$" src="form_9.png"/>.  <a href="#aca6bfb1722819752d1ad1084a6de6f27">More...</a><br/></td></tr>
<tr class="separator:aca6bfb1722819752d1ad1084a6de6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a3b1fbc500a01972017dabccfbcd6ebc1">D_lgamma</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of the n'th order derivative of the log gamma function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]" src="form_10.png"/>
</p>
<p> where the 2 input parameters are passed as a vector <img class="formulaInl" alt="$x=(\lambda,n)$" src="form_11.png"/>. The special case <img class="formulaInl" alt="$n=0$" src="form_2.png"/> gives the log gamma function.  <a href="#a3b1fbc500a01972017dabccfbcd6ebc1">More...</a><br/></td></tr>
<tr class="separator:a3b1fbc500a01972017dabccfbcd6ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a29ad7d7fdc9702c597b6d76d3ef281e3">ppois</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of poisson cdf <img class="formulaInl" alt="$ppois(n,\lambda)$" src="form_12.png"/>. Valid parameter range: <img class="formulaInl" alt="$x =(n,\lambda) \in \mathbb{N}_0\times\mathbb{R}_+$" src="form_13.png"/>.  <a href="#a29ad7d7fdc9702c597b6d76d3ef281e3">More...</a><br/></td></tr>
<tr class="separator:a29ad7d7fdc9702c597b6d76d3ef281e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82cfa85fbc2864a8b8d583144cb333"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:acf82cfa85fbc2864a8b8d583144cb333"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#acf82cfa85fbc2864a8b8d583144cb333">besselK</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:acf82cfa85fbc2864a8b8d583144cb333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of <img class="formulaInl" alt="$besselK(x,\nu)$" src="form_14.png"/>. Valid parameter range: <img class="formulaInl" alt="$x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}$" src="form_15.png"/>.  <a href="#acf82cfa85fbc2864a8b8d583144cb333">More...</a><br/></td></tr>
<tr class="separator:acf82cfa85fbc2864a8b8d583144cb333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a1ea1a599dfa8b5b10af52c40be19210e">matmul</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a1ea1a599dfa8b5b10af52c40be19210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix.  <a href="#a1ea1a599dfa8b5b10af52c40be19210e">More...</a><br/></td></tr>
<tr class="separator:a1ea1a599dfa8b5b10af52c40be19210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991f5af63e94ad38f54c99a81823efc"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a4991f5af63e94ad38f54c99a81823efc"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a4991f5af63e94ad38f54c99a81823efc">matinv</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a4991f5af63e94ad38f54c99a81823efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of matrix inversion. Inverts n-by-n matrix by LU-decomposition.  <a href="#a4991f5af63e94ad38f54c99a81823efc">More...</a><br/></td></tr>
<tr class="separator:a4991f5af63e94ad38f54c99a81823efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#af7937bd97f9d5a2e80c00d03faf3a7c2">logdet</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of log determinant of positive definite n-by-n matrix.  <a href="#af7937bd97f9d5a2e80c00d03faf3a7c2">More...</a><br/></td></tr>
<tr class="separator:af7937bd97f9d5a2e80c00d03faf3a7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dc81e22f17e8319ad028d01840e048"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a60dc81e22f17e8319ad028d01840e048"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a60dc81e22f17e8319ad028d01840e048">invpd</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a60dc81e22f17e8319ad028d01840e048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of log determinant <em>and</em> inverse of positive definite n-by-n matrix. Calculated by Cholesky decomposition.  <a href="#a60dc81e22f17e8319ad028d01840e048">More...</a><br/></td></tr>
<tr class="separator:a60dc81e22f17e8319ad028d01840e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3388f447891783f25d35a0d4994c8246"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a3388f447891783f25d35a0d4994c8246"><td class="memTemplItemLeft" align="right" valign="top">CppAD::vector&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatomic.html#a3388f447891783f25d35a0d4994c8246">expm</a> (CppAD::vector&lt; Type &gt; x)</td></tr>
<tr class="memdesc:a3388f447891783f25d35a0d4994c8246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic version of generalized matrix exponential (closed under reverse mode differentiation).  <a href="#a3388f447891783f25d35a0d4994c8246">More...</a><br/></td></tr>
<tr class="separator:a3388f447891783f25d35a0d4994c8246"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace with special functions and derivatives. </p>
<p>This namespace extends the 'derivatives table' of <a class="el" href="namespaceCppAD.html">CppAD</a>.</p>
<ul>
<li>R's special math library is extended with derivatives in cases where symbolic derivatives are available. These special functions are often iterative and therefore difficult to implement with AD types. Instead, we code the derivatives based on the double versions available from R. This approach requires fewer code lines, and has the benefit of obtaining the same high accuracy as R's math functions.</li>
<li>Some matrix operations are extended with derivatives. This greatly reduces the AD memory usage. Furthermore, these atomic operations can be linked to a performance library by setting preprocesor flag EIGEN_USE_BLAS.</li>
<li>New symbols can be added by advanced users. First option is to code the reverse mode derivatives by hand using the TMB_ATOMIC_VECTOR_FUNCTION macro, see source code for examples. Second option is to generate reverse mode derivatives automatically using the macro REGISTER_ATOMIC. </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a6dd8f490d3ca65864095d40de4f9fa85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::LDLT&lt;Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; &gt; <a class="el" href="namespaceatomic.html#a6dd8f490d3ca65864095d40de4f9fa85">atomic::LDLT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00440">440</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5cfd576878b02e6f3671443801b00a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::args2vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; <a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt; &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expm_8hpp_source.html#l00207">207</a> of file <a class="el" href="expm_8hpp_source.html">expm.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#ac09966696ad9685dc8047d6c582bc0ae">expm()</a>.</p>

</div>
</div>
<a class="anchor" id="acf82cfa85fbc2864a8b8d583144cb333"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::besselK </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of <img class="formulaInl" alt="$besselK(x,\nu)$" src="form_14.png"/>. Valid parameter range: <img class="formulaInl" alt="$x =(x,\nu) \in \mathbb{R}_+\times\mathbb{R}$" src="form_15.png"/>. </p>
<dl class="section note"><dt>Note</dt><dd>Derivative wrt. <img class="formulaInl" alt="$\nu$" src="form_16.png"/> is currently not implemented. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="convenience_8hpp.html#a5db7378b0391ca8feaece5d7026202bc">besselK()</a>.</p>

</div>
</div>
<a class="anchor" id="ab86d10e39e1b3aebc1fbd26aa26346d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::D_incpl_gamma_shape </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of scaled incomplete gamma function differentiated to any order wrt. shape parameter </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \log(t)^n \:dt \]" src="form_0.png"/>
</p>
<p> where the 4 input parameters are passed as a vector <img class="formulaInl" alt="$x=(y,\lambda,n,c)$" src="form_1.png"/>. Note that the normalized incomplete gamma function is obtained as the special case <img class="formulaInl" alt="$n=0$" src="form_2.png"/> and <img class="formulaInl" alt="$c=-\log \Gamma(\lambda)$" src="form_3.png"/>. Valid parameter range: <img class="formulaInl" alt="$x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{N}_0\times\mathbb{R}$" src="form_4.png"/>. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="group__R__style__distribution.html#gaa242d798beb9de104780857a90b32a65">pgamma()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b1fbc500a01972017dabccfbcd6ebc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::D_lgamma </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of the n'th order derivative of the log gamma function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{d^n}{d\lambda^n}\log \Gamma(\lambda) \]" src="form_10.png"/>
</p>
<p> where the 2 input parameters are passed as a vector <img class="formulaInl" alt="$x=(\lambda,n)$" src="form_11.png"/>. The special case <img class="formulaInl" alt="$n=0$" src="form_2.png"/> gives the log gamma function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="lgamma_8hpp.html#a177b023eb871927fcfc90259e9f00382">lgamma()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ac815ccadc31fa4bf92660fe5c25eab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type atomic::dnorm1 </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard normal density function 'dnorm1'. Needed to define derivative of 'pnorm1'. </p>

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00157">157</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6763243aac45f66d92084428c131133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_pade &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">matrix_pade atomic::expm </td>
          <td>(</td>
          <td class="paramtype">matrix_pade&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expm_8hpp_source.html#l00159">159</a> of file <a class="el" href="expm_8hpp_source.html">expm.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#ac09966696ad9685dc8047d6c582bc0ae">expm()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1cf45e4527ec63384948fc5deda6fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;double&gt; atomic::expm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; <a class="el" href="structmatrix.html">matrix</a>&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3388f447891783f25d35a0d4994c8246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::expm </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of generalized matrix exponential (closed under reverse mode differentiation). </p>
<pre class="fragment">   Generalized matrix exponential:
   
   C(x1,x2,...,xn)
   
   Example: n=3
   
   [ C(x1)       ]        [ x1          ]   [ I ]
   [ C(x1,x2)    ] = expm [ x2 x1       ] * [ 0 ]
   [ C(x1,x3)    ]        [ x3    x1    ]   [ 0 ]
   [ C(x1,x2,x3) ]        [    x3 x2 x1 ]   [ 0 ]

   d/dx1 ( sum( C(x1,x2,x3) * x4 ) ) = C(x1^T, x2^T, x3^T, x4)
   d/dx2 ( sum( C(x1,x2,x3) * x4 ) ) = C(x1^T,       x3^T, x4)
   d/dx3 ( sum( C(x1,x2,x3) * x4 ) ) = C(x1^T, x2^T,       x4)
</pre> 
</div>
</div>
<a class="anchor" id="ac09966696ad9685dc8047d6c582bc0ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt; atomic::expm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix exponential. </p>

<p>Definition at line <a class="el" href="expm_8hpp_source.html#l00295">295</a> of file <a class="el" href="expm_8hpp_source.html">expm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87a28796fe0610d708c2694a5cd6c2d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::ADFun&lt;Base&gt;* atomic::forrev </td>
          <td>(</td>
          <td class="paramtype">CppAD::ADFun&lt; AD&lt; Base &gt; &gt; *&#160;</td>
          <td class="paramname"><em>padf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift tape of fn up one level by taping forward and reverse sweeps. Note: x_ needs only have length equal to the input domain dimension of f0. Zeros are filled in for all range directions. </p>

<p>Definition at line <a class="el" href="checkpoint__macro_8hpp_source.html#l00078">78</a> of file <a class="el" href="checkpoint__macro_8hpp_source.html">checkpoint_macro.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#add38af63d55c1d476da416ee12ea2955">multi_forrev()</a>.</p>

</div>
</div>
<a class="anchor" id="a472890c63423ca4faac24b60ebc7dfb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base , class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::ADFun&lt;Base&gt;* atomic::generate_tape </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a tape of a given template <em>functor</em> (Will be used to tape 'f0' for different nested AD types) </p>

<p>Definition at line <a class="el" href="checkpoint__macro_8hpp_source.html#l00061">61</a> of file <a class="el" href="checkpoint__macro_8hpp_source.html">checkpoint_macro.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca6bfb1722819752d1ad1084a6de6f27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::inv_incpl_gamma </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of inverse of scaled incomplete gamma function. Given <img class="formulaInl" alt="$z$" src="form_5.png"/> find <img class="formulaInl" alt="$y$" src="form_6.png"/> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ z = \exp(c) \int_0^{y} \exp(-t) t^{\lambda-1} \:dt \]" src="form_7.png"/>
</p>
<p> where the 3 input parameters are passed as a vector <img class="formulaInl" alt="$x=(z,\lambda,c)$" src="form_8.png"/>. The special case <img class="formulaInl" alt="$c=-\log \Gamma(\lambda)$" src="form_3.png"/> gives the inverse normalized incomplete gamma function. Valid parameter range: <img class="formulaInl" alt="$x \in \mathbb{R}_+\times\mathbb{R}_+\times\mathbb{R}$" src="form_9.png"/>. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="group__R__style__distribution.html#gae9f8112d1f1ee80879c8e91b7bffac55">qgamma()</a>.</p>

</div>
</div>
<a class="anchor" id="a60dc81e22f17e8319ad028d01840e048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::invpd </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of log determinant <em>and</em> inverse of positive definite n-by-n matrix. Calculated by Cholesky decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1+n*n. </dd></dl>

<p>Referenced by <a class="el" href="namespaceatomic.html#a06aed041873dea3426da0d0bac628583">matinvpd()</a>.</p>

</div>
</div>
<a class="anchor" id="af7937bd97f9d5a2e80c00d03faf3a7c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::logdet </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of log determinant of positive definite n-by-n matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="laplace_8cpp-example.html#a5">laplace.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="namespaceatomic.html#ae5555ee5c905915a566d47d7f2830424">logdet()</a>, and <a class="el" href="namespaceatomic.html#acf2548954dc9fb42802b8d41e959337d">nldmvnorm()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5555ee5c905915a566d47d7f2830424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type atomic::logdet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00514">514</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58d9a6c916055fb65ca680ff55e7d7c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::mat2vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Eigen::Matrix to CppAD::vector by stacking the matrix columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00139">139</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#ae5555ee5c905915a566d47d7f2830424">logdet()</a>, <a class="el" href="namespaceatomic.html#acf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv()</a>, and <a class="el" href="namespaceatomic.html#a06aed041873dea3426da0d0bac628583">matinvpd()</a>.</p>

</div>
</div>
<a class="anchor" id="a4991f5af63e94ad38f54c99a81823efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::matinv </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of matrix inversion. Inverts n-by-n matrix by LU-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length n*n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n*n. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="laplace_8cpp-example.html#a4">laplace.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="namespaceatomic.html#acf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv()</a>, and <a class="el" href="namespaceatomic.html#acf2548954dc9fb42802b8d41e959337d">nldmvnorm()</a>.</p>

</div>
</div>
<a class="anchor" id="acf8e4c3cd2dc2c2859f8c52ad40ccec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt; atomic::matinv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00500">500</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06aed041873dea3426da0d0bac628583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt; atomic::matinvpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>logdet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00506">506</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

<p>Referenced by <a class="el" href="classMVNORM__t.html#af6f3969e9b727800d86b2e86ea8745af">MVNORM_t&lt; scalartype_ &gt;::setSigma()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea1a599dfa8b5b10af52c40be19210e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::matmul </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of matrix multiply. Multiplies n1-by-n2 matrix with n2-by-n3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2+n1*n2+n2*n3 containing the output dimension (length=2), the first matrix (length=n1*n2) and the second matrix (length=n2*n3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length n1*n3 containing result of matrix multiplication. </dd></dl>

<p>Referenced by <a class="el" href="namespaceatomic.html#a481538cdd18f419396ee65eaec62c0ba">matmul()</a>.</p>

</div>
</div>
<a class="anchor" id="a481538cdd18f419396ee65eaec62c0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt; atomic::matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply. </p>

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00491">491</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add38af63d55c1d476da416ee12ea2955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADBase &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::ADFun&lt;double&gt;* atomic::multi_forrev </td>
          <td>(</td>
          <td class="paramtype">CppAD::ADFun&lt; ADBase &gt; *&#160;</td>
          <td class="paramname"><em>padf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively apply forrev until the lowest Base level (double) </p>

<p>Definition at line <a class="el" href="checkpoint__macro_8hpp_source.html#l00098">98</a> of file <a class="el" href="checkpoint__macro_8hpp_source.html">checkpoint_macro.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#a8f24dc404dcd4e67da9eb5431af90a25">tape_symbol()</a>.</p>

</div>
</div>
<a class="anchor" id="ae97cc856848039d8348814b3cd969053"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::ADFun&lt;double&gt;* <a class="el" href="namespaceatomic.html#add38af63d55c1d476da416ee12ea2955">atomic::multi_forrev</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">CppAD::ADFun&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>padf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="checkpoint__macro_8hpp_source.html#l00102">102</a> of file <a class="el" href="checkpoint__macro_8hpp_source.html">checkpoint_macro.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf2548954dc9fb42802b8d41e959337d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type atomic::nldmvnorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00522">522</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae501e991d939deb58f6455904262be81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::pnorm1 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of standard normal distribution function. Derivative is known to be 'dnorm1'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="group__R__style__distribution.html#gac908a1b293d159f4a8958a694674a4a4">pnorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a29ad7d7fdc9702c597b6d76d3ef281e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::ppois </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of poisson cdf <img class="formulaInl" alt="$ppois(n,\lambda)$" src="form_12.png"/>. Valid parameter range: <img class="formulaInl" alt="$x =(n,\lambda) \in \mathbb{N}_0\times\mathbb{R}_+$" src="form_13.png"/>. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed on parameters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="group__R__style__distribution.html#ga21965e84a53d083256382b7eeb0383e7">ppois()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bb7b5e1dbb5ed751e3320b3f07bef77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::vector&lt;Type&gt; atomic::qnorm1 </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic version of standard normal quantile function. Derivative is expressed through 'dnorm1'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of length 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length 1. </dd></dl>

<p>Referenced by <a class="el" href="group__R__style__distribution.html#ga5fe727a0b7c4861fbab1f2a374a9fed2">qnorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f24dc404dcd4e67da9eb5431af90a25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CppAD::ADFun&lt;double&gt;* atomic::tape_symbol </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tape symbol up to any order. </p>

<p>Definition at line <a class="el" href="checkpoint__macro_8hpp_source.html#l00107">107</a> of file <a class="el" href="checkpoint__macro_8hpp_source.html">checkpoint_macro.hpp</a>.</p>

<p>Referenced by <a class="el" href="structatomic_1_1forrev__derivatives.html#a41b0194aa9bfc687d50e86d452b0dc4c">atomic::forrev_derivatives&lt; UserFunctor &gt;::do_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a6e5aae5b2ae6844132f48319048dd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix</a>&lt;Type&gt; atomic::vec2mat </td>
          <td>(</td>
          <td class="paramtype">CppAD::vector&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert segment of CppAD::vector to Eigen::Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector. </td></tr>
    <tr><td class="paramname">m</td><td>Number of rows in result. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns in result. </td></tr>
    <tr><td class="paramname">offset</td><td>Segment offset. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00129">129</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

<p>Referenced by <a class="el" href="namespaceatomic.html#ac09966696ad9685dc8047d6c582bc0ae">expm()</a>, <a class="el" href="namespaceatomic.html#acf8e4c3cd2dc2c2859f8c52ad40ccec0">matinv()</a>, <a class="el" href="namespaceatomic.html#a06aed041873dea3426da0d0bac628583">matinvpd()</a>, and <a class="el" href="namespaceatomic.html#a481538cdd18f419396ee65eaec62c0ba">matmul()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a586c7851a9b0f3ae2bccde6757b23b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atomic::atomicFunctionGenerated = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="atomic__math_8hpp_source.html#l00014">14</a> of file <a class="el" href="atomic__math_8hpp_source.html">atomic_math.hpp</a>.</p>

<p>Referenced by <a class="el" href="tmb__core_8hpp.html#a6b8df1abe5ed6096cc0a43c5812d703f">usingAtomics()</a>.</p>

</div>
</div>
</div><!-- contents -->
License: <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL v2</a>
